package appliers

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/thesabbir/hellfire/pkg/logger"
	"github.com/thesabbir/hellfire/pkg/uci"
	"github.com/thesabbir/hellfire/pkg/util"
)

const (
	DnsmasqConfigPath = "/etc/dnsmasq.d/hellfire.conf"
)

// DHCPApplier applies DHCP/DNS configuration
type DHCPApplier struct {
	previousConfig string
}

// NewDHCPApplier creates a new DHCP applier
func NewDHCPApplier() *DHCPApplier {
	return &DHCPApplier{}
}

// Name returns the applier name
func (a *DHCPApplier) Name() string {
	return "dhcp"
}

// Apply applies DHCP configuration
func (a *DHCPApplier) Apply(ctx context.Context, config *uci.Config) error {
	// Save current config for rollback
	if err := a.saveCurrentConfig(); err != nil {
		logger.Warn("Failed to save current DHCP config", "error", err)
	}

	// Generate dnsmasq configuration
	dnsmasqConfig, err := a.generateDnsmasqConfig(config)
	if err != nil {
		return fmt.Errorf("failed to generate dnsmasq config: %w", err)
	}

	// Write configuration file
	if err := a.writeDnsmasqConfig(dnsmasqConfig); err != nil {
		return fmt.Errorf("failed to write dnsmasq config: %w", err)
	}

	// Restart dnsmasq
	if err := a.restartDnsmasq(ctx); err != nil {
		return fmt.Errorf("failed to restart dnsmasq: %w", err)
	}

	return nil
}

// Validate validates that dnsmasq is running
func (a *DHCPApplier) Validate(ctx context.Context) error {
	// Check if dnsmasq is running using systemctl (Debian Trixie+ with systemd)
	cmd := exec.CommandContext(ctx, "systemctl", "is-active", "dnsmasq")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("dnsmasq is not running")
	}

	return nil
}

// Rollback rolls back DHCP changes
func (a *DHCPApplier) Rollback(ctx context.Context) error {
	if a.previousConfig == "" {
		return fmt.Errorf("no previous config to restore")
	}

	logger.Info("Rolling back DHCP configuration")

	// Restore previous config
	if err := a.writeDnsmasqConfig(a.previousConfig); err != nil {
		return err
	}

	// Restart dnsmasq
	return a.restartDnsmasq(ctx)
}

// saveCurrentConfig saves the current dnsmasq configuration
func (a *DHCPApplier) saveCurrentConfig() error {
	data, err := os.ReadFile(DnsmasqConfigPath)
	if err != nil {
		if os.IsNotExist(err) {
			a.previousConfig = ""
			return nil
		}
		return err
	}

	a.previousConfig = string(data)
	return nil
}

// generateDnsmasqConfig generates dnsmasq configuration from UCI config
func (a *DHCPApplier) generateDnsmasqConfig(config *uci.Config) (string, error) {
	var buf bytes.Buffer

	buf.WriteString("# Generated by Hellfire\n\n")

	// Process DHCP pools
	dhcpPools := config.GetSectionsByType("dhcp")
	for _, pool := range dhcpPools {
		iface, ok := pool.GetOption("interface")
		if !ok {
			continue
		}

		// Validate interface name
		if err := util.ValidateInterfaceName(iface); err != nil {
			return "", fmt.Errorf("invalid interface name %s: %w", iface, err)
		}

		// Check if DHCP is disabled for this interface
		if ignore, ok := pool.GetOption("ignore"); ok && ignore == "1" {
			continue
		}

		// DHCP range
		start, hasStart := pool.GetOption("start")
		limit, hasLimit := pool.GetOption("limit")
		leasetime, _ := pool.GetOption("leasetime")

		if hasStart && hasLimit {
			// Validate start and limit IPs
			if err := util.ValidateIPAddress(start); err != nil {
				return "", fmt.Errorf("invalid start IP %s: %w", start, err)
			}
			if err := util.ValidateIPAddress(limit); err != nil {
				return "", fmt.Errorf("invalid limit IP %s: %w", limit, err)
			}

			if leasetime == "" {
				leasetime = "12h"
			}
			buf.WriteString(fmt.Sprintf("dhcp-range=%s,%s,%s,%s\n", iface, start, limit, leasetime))
		}

		// DHCP options
		if gateway, ok := pool.GetOption("dhcp_option"); ok {
			buf.WriteString(fmt.Sprintf("dhcp-option=%s,%s\n", iface, gateway))
		}
	}

	// Process DNS settings
	dnsmasq := config.GetSection("dnsmasq", "")
	if dnsmasq != nil {
		// Domain
		if domain, ok := dnsmasq.GetOption("domain"); ok {
			// Validate domain name
			if err := util.ValidateHostname(domain); err != nil {
				return "", fmt.Errorf("invalid domain %s: %w", domain, err)
			}
			buf.WriteString(fmt.Sprintf("domain=%s\n", domain))
		}

		// Local domain
		if local, ok := dnsmasq.GetOption("local"); ok {
			// Validate local domain
			if err := util.ValidateHostname(local); err != nil {
				return "", fmt.Errorf("invalid local domain %s: %w", local, err)
			}
			buf.WriteString(fmt.Sprintf("local=/%s/\n", local))
		}

		// Upstream DNS servers
		servers := dnsmasq.GetList("server")
		for _, server := range servers {
			// Validate DNS server IP
			if err := util.ValidateIPAddress(server); err != nil {
				return "", fmt.Errorf("invalid DNS server %s: %w", server, err)
			}
			buf.WriteString(fmt.Sprintf("server=%s\n", server))
		}
	}

	return buf.String(), nil
}

// writeDnsmasqConfig writes dnsmasq configuration to file
func (a *DHCPApplier) writeDnsmasqConfig(config string) error {
	// Ensure directory exists with restricted permissions
	dir := filepath.Dir(DnsmasqConfigPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	// Write config file with restricted permissions (owner read/write only)
	// dnsmasq typically runs as root, so 0600 is appropriate
	return os.WriteFile(DnsmasqConfigPath, []byte(config), 0600)
}

// restartDnsmasq restarts the dnsmasq service
func (a *DHCPApplier) restartDnsmasq(ctx context.Context) error {
	// Use systemctl (Debian Trixie+ with systemd)
	cmd := exec.CommandContext(ctx, "systemctl", "restart", "dnsmasq")
	if err := cmd.Run(); err != nil {
		logger.Error("Failed to restart dnsmasq", "error", err)
		return fmt.Errorf("failed to restart dnsmasq: %w", err)
	}

	logger.Info("Dnsmasq restarted successfully")
	return nil
}
